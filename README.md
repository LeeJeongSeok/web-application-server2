# 자바 웹 프로그래밍 Next Step

## 3.4 웹 서버 실습

###  3.4.2 실습 환경 세팅 및 소스코드 분석

- webserver.Webserver를 실행한 후 브라우저에서 http://localhost:8080/으로 접근했을 때 "Hello World" 메시지가 출력된다면 실습준비 끝
- HTTP 웹 서버의 핵심이 되는 코드는 webserver 패키지의 WebServer와 Request 클래스이다
- WebServer 클래스는 웹 서버를 시작하고, 사용자의 요청이 있을 때까지 대기 상태에 있다가 사용자 요청이 있을 경우 사용자 요청을 RequestHandler 클래스에 위임하는 역할을 한다.
- ServerSocket 클래스는 사용자 요청이 발생할 때까지 대기 상태에 있도록 지원하는 역할을 한다.
- WebServer 클래스는 ServerSocket에 사용자 요청이 발생하는 순간 클라이언트와 연결을 담당하는 Socket을 RequestHandler에 전달하면서 새로운 스레드를 실행하는 방식으로 멀티스레드 프로그래밍을 지원하고 있다.
- RequestHandler 클래스는 Thread를 상속하고 있으며, 사용자의 요청에 대한 처리와 응답에 대한 처리를 담당하는 가장 중심이 되는 클래스이다.

### 3.4.3.1 요구사항 1 - index.html 응답하기

- 실습환경을 세팅한 웹 서버에 접속하면 어떤 URL로 접속하더라도 "Hello World" 문자열을 반환하는 상태이다.

```java
byte[] body = "Hello World".getByte();
```

- http://localhost:8080/index.html로 접속했을 때 webapp 디렉토리의 index.html 파일을 읽어 클라이언트에 응답하도록 개발한다.
- HTTP header 예)

```
GET /index.html HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: */*
```

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 요쳥과 응답하는 과정에 InputSream, OutputStream를 사용하고, 실제 데이터를 byte 기반으로 주고 받는 사실이 신기했다.
- 생각보다 split() 메소드의 활용이 매우 높은것 같다.
- 책에 있는 참고자료로 인해 서버와 클라이언트의 통신하는 방법에 대해 알 수 있었다.
- 로그 메시지를 프로그램의 정상 실행 여부와, 어떤 데이터가 넘어오는지 확인할 수 있었고 그에 따른 로그 메시지의 중요성도 느낄 수 있었다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가 (2차 반복주기)

- 만약 url에 입력된 값이 null일 경우는 어떤 방식으로 처리를 해줘야할까?

- 단순히 분기처리문을 이용하여 처리하는 방식보단 조금 더 효과적인 방법이 없을까..

- 각 요청마다 클라이언트의 포트는 서로 다른 포트로 연결된다. 서버는 각 요청에 대해 순차적으로 실행하는 것이 아니라 동시에 각 요청에 대응하는 스레드(Thread-0, Thread-1)를 생성해 동시에 실행한다.

- 요청에 대한 첫 번째 라인은 아래와 같은 형태로 구성되어 있다.

  > GET /index.html HTTP1.1

- 첫 번째 라인을 제외한 나머지 요청 데이터는 "<필드 이름>: <필드 값>" 형태로 구성되어 있다.

- 각 요청의 마지막은 빈 문자열("")로 구성되어 있다. (**개인적인 생각이지만 HTTP를 이해하는 과정중에서 쉬우면서도 중요한 이론중 하나이지 않을까 싶다.**)

- 웹 클라이언트는 웹 서버와 데이터를 주고 받기 위해 HTTP라는 서로 간에 약속된 규약은 아래와 같으며 통신하기 위해선 규약을 따라야만 한다.

  ```
  POST /user/create HTTP/1.1 // -> 요청 라인
  Host: localhost:8080 // 1
  Content-Length: 59 // 2													
  Content-Type: application/x-www-form-urlencoded // 3
  Accept: */* // 4 -> 1 ~ 4번까지 요청 헤더
  ----------------------------------------------> 헤더와 본문 사이의 빈 공백 라인이 존재!
  userId=javajigi&password=password //-> 요청 본문
  ```

- 요청 라인(RequestLine)

  - 'HTTP-메소드 URI HTTP-버전' 형식으로 구성되어 있음
  - HTTP 메소드는 요청의 종류를 나타낸다 (Ex GET, POST)
  - URI는 클라이언트가 서버에 유일하게 식별할 수 있는 요청 자원의 경로를 의미한다.
  - HTTP-버전은 현재 요청의 HTTP 버전으로 현재는 1.1이 주로 사용되고 있다.
    - [HTTP-버전](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)

- 요청 헤더(Request Headers)

  - <필드 이름>: <필드 값> 형태에 쌍으로 구성되어 있음, 만약 필드 이름 하나에 여러 개의 필드 값을 전달하고 싶으면 쉼표(,)를 구분자로 전달할 수 있다.

    > <필드 이름>: <필드 값1>, <필드 값2>

- 응답 헤더(Response Headers)

  - 요청 헤더와 동일하게 클라이언트에서 요청을 받으면 서버는 클라이언트 요청에 대한 응답을 해야한다.(대화의 티키타카마냥)
  - 서버에서 보내는 응답 또한 헤더와, 본문으로 구성되어 있다. 아래에 예시로 응답 메시지를 클라이언트로 보내준다.

  ```
  HTTP/1.1 200 OK // -> 상태 라인
  Content-Type: text/html;charset=utf-8 // 1
  Content-Length: 20 // 2  -> 1 ~ 2번까지 응답 헤더
  ----------------------------------------------> 헤더와 본문 사이의 빈 공백 라인이 존재!
  <h1>Hello World</h1> //-> 응답 본문
  ```

  - 응답 메시지의 문법 또한 요청 메시지와 같다. 단지 다른 점이라면 첫 번째 라인의 형식이 다르다는 것이다.

- 상태 라인(Status Line)

  - 응답 헤더의 첫 번째 라인은 상태 라인이라고 부르며 "HTTP-버전 상태코드 응답구문" 형식으로 구성되어 있다.
  - HTTP-버전은 요청 라인에 있는 HTTP-버전과 같은 의미이고, 상태코드는 응답에 대한 상태를 의미하는 코드 값으로 200은 성공을 나타낸다. 응답 구문은 응답 상태에 대한 설명이다.

- **제일 궁금했던 부분**

  - index.html에 대한 요청을 한번만 보넀는데 css, js, 이미지, 아이콘 등의 여러 개의 파일들이 추가적으로 요청이 생기는 이유가 궁금했다.
  - 많은 요청이 발생하는 이유는 서버가 웹 페이지를 구성하는 모든 자원을 한번에 응답으로 보내지 않기 때문이다. 
    - 과정을 먼저 살펴보면
    - 먼저 /index.html에 대한 요청에 대한 응답을 HTML만 보낸다.
    - 응답 받은 브라우저는 HTML을 분석하여 css, js, 이미지, 아이콘 등의 자원이 포함되어 있다면 서버에 해당 자원을 다시 요청하게 된다.
    - 따라서 하나의 웹 페이지를 사용자에게 정상적으로 서비스하려면 클라이언트와 서버 간의 여러 번의 요청과 응답이 이루어진다.

### 3.4.3.2 요구사항 2 - GET 방식으로 회원가입하기

- "회원가입" 메뉴를 클릭하면 http://localhost:8080/user/form.html으로 이동하면서 회원가입을 할 수 있다.
- HTTP header 예)

```
/user/create?userId=javajigi&password=password&name=JaeSung&email=javajigi
```

- 위와 같은 형태로 사용자가 입력한 값이 서버에 전달된다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 이미 구현되어있는 클래스 HttpRequestUtils에 속한 메소드들이 신기했다.
- URL에서 '?' 이후에 전달되는 queryString을 내부적으로 어떻게 처리하는지에 대해 알 수 있었다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가 (2차 반복주기)

- GET 메소드 방식으로 요청을 보낼 경우 사용자가 입력한 값을 물음표를 요청 URI에 붙혀 매개변수명1=값1&매개변수명2=값2 형식으로 전송한다.

### 3.4.3.3 요구사항 3 - POST 방식으로 회원가입하기

- GET 방식과 동일한 데이터를 가지고 그대로 POST 방식으로 회원가입을 구현해야 한다.
- POST 방식은 GET 방식과는 다르게 HTTP header가 아닌 본문 즉 body로부터 넘어온다. (쿼리스트링이 본문으로 넘어오기 때문)
- HTTP body는 header 이후에 빈 공백을 가지는 한 줄 다음부터 시작한다.
- 나머지는 GET 방식과 동일하게 구현하면 된다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 각각의 방식별로 데이터가 어디로 넘어오는지 확인할 수 있었고, 버전에 차이인진 모르겠지만, 단순히 form 태그에 메소드만 post로 바꾼거 밖에 없는데 신기하겓 돌아간다...왜지..책에 있는 IOUtils 클래스의 readData() 메소드를 활용하지 않아도 구현이 가능했다.
- 현재 이런식의 코드라면..get, post를 동시에 수용할 수 없는 코드가 된다. get방식은 URI 요청 경로 뒤에 ?로 시작해서 parameter 값을 전달하는데 post 방식은 body 전달하기 때문에 현재 코드에선 동시다발적으로 수용할 수 없다. 추가적으로 get과 post를 먼저 구분 짓고, 추후에 분기처리 구문을 이용하여 처리하는 것도 하나에 방법인것 같다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가 (2차 반복주기)

- 아직까지 post 방식을 활용하여 boy에서 원하는 데이터를 가져오는 방법에 대해 이해가 부족한 듯 하다.
- post 방식으로 데이터가 전송되면 요청 header 부분에 Content-Length 항목에 body의 길이가 출력된다.
- 이때 서버 쪽에서 Content-Length 만큼 데이터를 읽어주면 그 부분이 요청 body가 된다. 
- HTTP-메소드의 형태가 댜앙하다
  - 웹 애플리케이션을 만들면서 자주 사용하는 것이 GET, POST가 있다 하지만 이 둘 이외에 HEAD, PUT, DELETE, PATCH, TRACE, OPTIONS 메소드를 지원한다. 하지만 웹 애플리케이션 개발 초기 공부하고 있는 입장에선 GET, POST만 사용할 가능성이 높기 때문에 다른 메소드들에 대해선 아직까진 깊게 알아볼 필요는 없다.
  - GET, POST만 사용하는 이유는 HTML에서 GET과 POST만 사용 가능하도록 지원하고 있기 때문이다.
  - HTML의 모든 <a> 태그 링크, css, js, 이미지 요청은 모두 GET 방식으로 요청을 보내고 POST 방식은 <form> 태그를 통해 요청을 보낼 수 있는데 이때 <form> 태그가 지원하는 방식은 GET, POST 밖에 없다.
  - 하지만 REST API, AJAX 기반에 웹 애플리케이션은 PUT, DELETE 메소드까지 활용하는 추세이다.
- GET은 서버에 존재하는 데이터를 가져오는 것이고 POST는 서버에 요청을 보내 데이터 추가, 수정, 삭제와 같은 작업을 실행하도록 하는 것이다.
  - 즉, GET은 서버에 존재하는 데이터를 조회하는 역할이고 상태를 변경하진 않는다.
  - POST는 데이터의 상태를 변경하는 작업을 담당한다.

### 3.4.3.4 요구사항 4 - 302 status code 적용

- "회원가입"을 완료하면 /index.html 페이지로 이동하고 싶다.
- 현재까지는 /user/create 요청시 따로 응답 처리를 해주지 않았으므로 페이지가 정상적으로 노출되지 않는다.
- 즉, 회원가입이 완료가 되면 요청에 따라 응답 페이지인 index.html 파일을 노출시킨다.

```
- HTTP 응답 헤더의 status code를 200이 아니라 302 code를 사용한다.
```

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 서버쪽에서 어떻게 응답하냐에 따라 클라이언트에게 보여지는 화면이 다를 수 있다는 것과, 웹 어플리케이션의 흐름은 서버쪽 흐름에 따라 많이 달라지는 것 같다.
- 또한 응답 코드별로 응답 header에 들어가는 내용들이 다르다는 것도 알았다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가 (2차 반복주기)

- 302 code를 적용하기 전까지는 새로고침을 아무리 해도 이전 요청 정보가 전송된다는 사실을 알았다.
  - 공부하는 입장에선 별거 아니라는 생각이 들겠지만, 만약 이게 DB와 연동되어 있는 웹 애플리케이션이라면 데이터가 중복이 되는 문제점이 발생한다.
  - 응답을 보낼때 상태 코드를 302로 지정해주고, 응답 헤더의 Location: /index.html 형식으로 응답을 보내면 된다.
  - 응답을 받은 클라이언트는 첫 라인의 상태 코드를 읽고 확인한 후 Location 값을 읽어 서버에 재요청을 한다.
- 302 code를 적용하기 전에는 클라이언트와 서버 사이의 요청과 응답이 각각 1번씩 이루어 졌다.
- 302 code를 적용하면 요청과 응답디 한 번이 아니라 두 번 발생한다.
  - /user/create 요청(1) -> 회원가입 처리 -> /index.html로 302 응답(1)
  - /index.html 요청(2) -> /index.html 읽기 -> /index.html 200 응답(2)

위키페디아 검색 결과에 따르면, 'HTTP 응답 상태 코드 302 찾기는 URL 리다이렉션을 수행하는 일반적인 방법입니다.'라고 나와있다. 

#### 리다이렉션?

> **URL 리다이렉션**(URL redirection← URL 넘겨주기)은 이용 가능한 [웹 페이지](https://ko.wikipedia.org/wiki/웹_페이지)를 하나 이상의 [URL](https://ko.wikipedia.org/wiki/URL) 주소로 만들어주는 [월드 와이드 웹](https://ko.wikipedia.org/wiki/월드_와이드_웹) 기법이다. **URL 포워딩**(URL forwarding)이라고도 한다. 넘겨받은 URL을 [웹 브라우저](https://ko.wikipedia.org/wiki/웹_브라우저)가 열려고 하면 다른 URL의 문서가 열리게 된다.
>
> 출처 : https://ko.wikipedia.org/wiki/URL_리다이렉션

- 즉, 개발자가 설정한 url로 이동하는 기법중 하나이다.

  >**상태 코드**
  >
  >2XX : 성공. 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리.
  >
  >3XX : 리다이렉션. 클라이언트는 요청을 마치기 위해 추가 동작이 필요함
  >
  >4XX : 요청 오류. 클라이언트에 오류가 있음
  >
  >5XX : 서버 오류. 서버가 유효한 요청을 명백하게 수행하지 못했음

### 3.4.3.5 요구사항 5 - 로그인하기

- "로그인" 메뉴를 클릭하면 로그인 페이지로 이동한 후 로그인 처리를 한다. 성공한다면 /index.html 그렇지 않으면 /user/login_failed.html로 이동하는 로직을 작성하면 된다.
- 이때 쿠키를 활용하여 로그인 상태를 유지할 수 있으며, 로그인이 성공할 경우 쿠키의 헤어 값이 logined=true이고, 그렇지 않으면 logined=false로 전달되어야 한다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 쿠키값을 한번 서버로 부터 응답받은 후 설정이 되는 순간 그 후론 어느 요청이 와도 쿠키값은 브라우저에 존재한다.
- 요청도 요청이지만 응답을 주는 과정에서 값을 설정할 수 있다는 것이 서버 개발자가 뭔가 전지전능한것 처럼 느껴졌다
- split() 메소드와 동일하게 Map 형태에 자료형 또한 이번 과정에서 자주 사용되는 것 같다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가 (2차 반복주기)

- HTTP는 요청을 보내고 응답을 받으면 클라이언트와 서버 간의 연결을 끊는다. 이러한 이유로 인해 각 요청 사이에 상태를 공유할 수 없다. 이 때문에 HTTP를 무상태 프로토콜이라고 한다.
- 무상태 프로토콜이라는 이유로 인해 요청을 받는 쪽 즉, 서버 입장에선 클라이언트가 누구인지를 식별할 수 있는 방법이 없을 뿐만 아니라 클라이언트가 어떤 행위를 했는지 서버 입장에선 기억할 수 없다. 

##### 쿠키

- 웹 애플리케이션의 대표적인 기능 중 하나인 로그인 기능을 하나의 예로 들어보면, 우리가 로그인을 완료한 후 매 요청마다 로그인을 다시 하지 않는다. 왜 일까? 🤔

- HTTP는 로그인 기능과 같이 클라이언트의 행위를 기억하기 위한 목적으로 지원하는 것이 쿠키이다.

##### HTTP가 쿠키를 지원하는 방법

- 먼저 서버(클라이언트에서도 가능하지만 서버로 예를 시작함)에서 로그인 요청을 받으면 로그인 성공/실패 여부에 따라 응답 헤더에 Set-Cookie로 결과 값을 저장할 수 있다. 
- 클라이언트는 응답 헤더에 Set-Cookie가 존재할 경우 Set-Cookie의 값을 읽어 서버에 보낸다
- 서버에 보내는 요청 헤더의 Cookie 헤더 값으로 다시 전송한다. 
- HTTP는 각 요청 간에 데이터를 공유할 수 없기 때문에 요청/응답 헤더를 통해 데이터를 전송하면서 공유한다.

<img src="https://images.velog.io/images/ljs0429777/post/13d44e0b-55e5-4f52-be80-234b88140783/IMG_C9D11B096691-1.jpeg" style="zoom:30%;" />

### 3.4.3.6 요구사항 6 - 사용자 목록 출력

- 접근하고 있는 사용자의 상태 값에 따라 사용자 목록 페이지를 출력할지 말지 판단하는 로직을 작성한다.

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

이번 요구사항에선 **localhost에서 리다이렉션한 횟수가 너무 많습니다.** 라는 문제를 자주 접했고, 문제를 해결하면서 어떤 부분을 놓쳤는지에 대해 조금 작성해봤다.

- 접근하고 있는 사용자가 "로그인" 상태일 경우 위에서 만든대로 Set-Cookie 값으로 인해 Cookie: logined=true 값이 형성된다. 이때 쿠키값을 가지고 사용자가 로그인한 경우를 판단하여 유저목록 페이지를 보여줄 것인지, 로그인 페이지를 다시 보여주는 요구사항을 수행하다가 만난 오류이다.

  

  문제의 코드

  ```
  else if(url.startsWith("/user/list")) {
                  DataOutputStream dos = new DataOutputStream(out);
                  response302Header(dos, "/user/list.html");
  }
  ```

  url.startWith("/user/list")로 시작하는 url이 post로 요청이 들어오면 그에 맞는 웹페이지를 보여주는 형식으로 코드를 작성한 후 결과를 확인해봤는데 'localhost에서 리다이렉션한 횟수가 너무 많습니다.'라는 메시지를 확인했다. 생각한대로 로직을 작성했고, /user/list.html 파일 말고 다른 파일을 호출했을때는 정상적으로 잘 나왔다. 어떤 이유인지 몰라서 구글을 통해 원인을 찾아봤다. 

  > 서버에서 링크이동이 반복해서 이뤄지게 됐을 때 브라우저가 임의로 이 에러를 일으키는 것이다. 예를 들어 localhost라는 주소에 들어갔을 때 해당 웹페이지에 localhost/move로 리다이렉션시키는 스크립트가 짜여져 있고, localhost/move라는 곳으로 이동했을 때 localhost로 다시 리다이렉션시키는 스크립트가 있다면 이 오류가 뜨게 된다.
  >
  > 
  >
  > 출처 : https://this-programmer.tistory.com/entry/리다이렉션한-횟수가-너무-많습니다

  이러한 원인으로 인해 오류가 발생한다고 한다. 불연듯 생각났다. 나는 지금 /user/list를 호출하면 /user/list.html 파일을 호출하고 있고, /user/list.html 은 startWith 메소드로 인해 /user/list를 리다이렉션을 시키고 있었던 것이다..이런 문제를 해결하기 위해 equals 메소드를 사용해 해결하였다.

- 헤당 메세지는 url를 무한으로 순환호출하여 발생하는 메세지이다.

### 3.4.4.7 요구사항 7 - CSS 지원하기

- 지금까지 구현한 소스코드는 CSS 파일을 지원하지 못하고 있다. CSS 파일을 지원하게끔 로직을 작성하면 된다.

- 여태껏 html 형식으로 요청이 왔었다. 이때 header를 잘 분석해보면

  ```
  GET /user/create HTTP/1.1
  Host: localhost:8080
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  ```

- Accept 항목에 이 파일은 html 파일이라고 나타난다.

- 이때 css 파일이 들어올 땐 아래와 같은 형식으로 요청이 들어온다. 

  ```
  Accept: text/css 
  ```

#### 요구사항에 대한 문제를 해결하면서 무엇을 느끼고 학습했는가

- 약간 과대 표현을 하자면 서버측에서 클라이언트로 응답을 보낼때 헤더든 바디든..어떤 데이터도 보낼 수 있다? 라는 느낌을 받을 수 있었고, 클라이언트는 다른 일을 처리할 땐 모르지만, 단순히 요청만 행위를 봤을땐 바보같은 친구라는 사실을 알게 되었다..
- 이런식이라면 js 파일도 응답이 가능할 것 같다는 생각이 들었다.

### 3.5.2 빌드 도구 메이븐

- 빌드 도구는 프로젝트와 관련한 설정을 관리하면서 소스코드(프로덕션, 테스트 코드)에 대한 컴파일, 컴파일을 위해 필요한 라이브러리 관리, 테스트, 배포를 위한 패키징 작업 등의 작업을 자동화할 수 있도록 지원하는 도구이다.
- 메이븐에 속한 플러그인 중 컴파일과 관련된 플러그인은 실서버(리눅스)에도 소스코드가 정상적으로 컴파일이 될 수 있게끔 포함되어 있는 플러그인이다. 윈도우 혹은 맥 같은 GUI 환경에선 이클립스나 IntelliJ 같은 IDE 상에서 저장만 하면 알아서 컴파일을 해주기 때문에 내가 몰랐던 사실이다.

### 3.5.3 디버깅을 위한 로깅(logging)

- 애플리케이션이 정상적으로 동작하는지 확인하기 위한 목적, 애플리케이션에 문제가 발생했을 때 원인을 파악하기 위한 디버깅을 목적으로 수많은 메세지를 출력하는데 그 중 자바 api인 **System.out.println()** 을 자주 사용하곤 한다.
- 하지만 **System.out.println()** 방식은 애플리케이션의 성능을 저하시키는 원인이다. 구체적인 이유는 더 찾아봐야겠지만, 책에선 디버깅 메시지를 출력하면 파일로 메시지가 출력하게 되고, 파일에 메시지를 출력하는 작업은 상당한 비용이 발생하는 작업이라고 한다.
- 이러한 문제로 인해 배포하기전 소스코드에 포함되어 있는 **System.out.println()** 코드를 삭제하거나 주석처리한다. 또한 디버깅을 목적으로 출력하고 싶다면 다시 원복시켜야 한다는 문제가 있다.

> 여기까지만 해도 지금까지 System.out.println() 사용한 내 자신을 반성해야한다고 느꼈다. 하지만 왜 성능이 저하대는지는 아직까진 이해가 되지 않는다. 왜 성능 이슈가 발생할까?

#### 로깅(Logging) 프레임워크

- 기존에 자바 API를 활용하여 디버깅를 하면서 불편한점을 개선하고자 나온 프레임워크가 로깅 프레임워크이다. 대표적으로 Log4J, Logback이 있다. 사용방법은 간단하다 pom.xml에 관련된 dependency를 설정과 logback과 관련된 xml 파일을 만들어주면 된다.
- 이때 logback.xml 파일은 maven이 기본적으로 인식할 수 있는 경로인 /src/main/resources/ 디렉토리 안에 있어야 한다.

```xml
<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
			<version>1.1.2</version>
</dependency>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration>
<configuration>
	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
		<layout class="ch.qos.logback.classic.PatternLayout">
			<Pattern>%d{HH:mm:ss.SSS} [%-5level] [%thread] [%logger{36}] - %m%n</Pattern>
		</layout>
	</appender>
	
	<root level="DEBUG">
		<appender-ref ref="STDOUT" />
	</root>
</configuration>
```

#### 내가 작성한 코드와 박재성님이 작성한 코드의 비교

- 기존 Map 형식으로 헤더의 값을 저장했음, 하지만 박재성님의 was-step1-bad-version 브랜치를 보면 동일하게 while 문을 통해 헤더를 분석하지만, 따로 집단 자료형 형태로 저장하지 않음
- 그 이유를 좀 더 생각해보니, 헤더의 필드 값을 사용하는 경우가 많지 않고, 사용하는 빈도수가 낮다고 생각이 들었다.
- 회원가입시 post 전송, 로그인, 유저 리스트 조회 인 경우에만 헤더의서 필드 값을 가져오는 형태였다. 그렇기 때문에 변수로 처리하는 게 더 쉬운 방법이지 않을까 싶었다.
- 기존에 나의 코드는 너무 무지성으로 리펙토링 하지 않았나 싶다. 리펙토링 기준은 우선 한 메소드에 들여쓰기가 2가 넘어가면 무조건 리펙토링 대상으로 정했다. 그 결과 run 메소드안에 내용은 짧아졌지만 뭔가 객체지향적인 코드로 변경되진 않았다.
